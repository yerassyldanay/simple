// Code generated by sqlc. DO NOT EDIT.
// source: model_board_and_user.sql

package database

import (
	"context"
	"database/sql"
)

const createBoardUserRelation = `-- name: CreateBoardUserRelation :one
insert into board_responsible_users (board_id, user_id, authority_level)
values ($1, $2, $3) returning board_id, user_id, authority_level
`

type CreateBoardUserRelationParams struct {
	BoardID        sql.NullInt64 `json:"board_id"`
	UserID         sql.NullInt64 `json:"user_id"`
	AuthorityLevel sql.NullInt32 `json:"authority_level"`
}

func (q *Queries) CreateBoardUserRelation(ctx context.Context, arg CreateBoardUserRelationParams) (BoardResponsibleUser, error) {
	row := q.db.QueryRowContext(ctx, createBoardUserRelation, arg.BoardID, arg.UserID, arg.AuthorityLevel)
	var i BoardResponsibleUser
	err := row.Scan(&i.BoardID, &i.UserID, &i.AuthorityLevel)
	return i, err
}

const getBoardsByUserId = `-- name: GetBoardsByUserId :many
select id, name, created_at, board_id, user_id, authority_level from boards b inner join board_responsible_users bru on b.id = bru.board_id
where bru.user_id = $1 order by b.created_at limit $2 offset $3
`

type GetBoardsByUserIdParams struct {
	UserID sql.NullInt64 `json:"user_id"`
	Limit  int32         `json:"limit"`
	Offset int32         `json:"offset"`
}

type GetBoardsByUserIdRow struct {
	ID             int64         `json:"id"`
	Name           string        `json:"name"`
	CreatedAt      sql.NullTime  `json:"created_at"`
	BoardID        sql.NullInt64 `json:"board_id"`
	UserID         sql.NullInt64 `json:"user_id"`
	AuthorityLevel sql.NullInt32 `json:"authority_level"`
}

func (q *Queries) GetBoardsByUserId(ctx context.Context, arg GetBoardsByUserIdParams) ([]GetBoardsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getBoardsByUserId, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBoardsByUserIdRow
	for rows.Next() {
		var i GetBoardsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.BoardID,
			&i.UserID,
			&i.AuthorityLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByBoardId = `-- name: GetUsersByBoardId :many
select u.fio, u.email, u.phone, u.code from users u
inner join board_responsible_users bru on u.id = bru.user_id
where bru.board_id = $1 order by fio limit $2 offset $3
`

type GetUsersByBoardIdParams struct {
	BoardID sql.NullInt64 `json:"board_id"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
}

type GetUsersByBoardIdRow struct {
	Fio   string         `json:"fio"`
	Email sql.NullString `json:"email"`
	Phone sql.NullString `json:"phone"`
	Code  sql.NullString `json:"code"`
}

func (q *Queries) GetUsersByBoardId(ctx context.Context, arg GetUsersByBoardIdParams) ([]GetUsersByBoardIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByBoardId, arg.BoardID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByBoardIdRow
	for rows.Next() {
		var i GetUsersByBoardIdRow
		if err := rows.Scan(
			&i.Fio,
			&i.Email,
			&i.Phone,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
